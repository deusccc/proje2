import { GetirFoodClient } from './client'
import { GetirFoodSyncResult, GetirFoodSyncOptions } from '@/types/getir-food'
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!

const supabase = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
})

export class GetirFoodSyncService {
  private client: GetirFoodClient
  private restaurantId: string

  constructor(client: GetirFoodClient, restaurantId: string) {
    this.client = client
    this.restaurantId = restaurantId
  }

  // Tam senkronizasyon
  async syncAll(options: GetirFoodSyncOptions = {
    syncProducts: true,
    syncCategories: true,
    syncPrices: true,
    syncAvailability: true
  }): Promise<GetirFoodSyncResult> {
    try {
      console.log('üîÑ Starting full Getir Food sync...')
      
      let totalSynced = 0
      let totalFailed = 0
      const errors: string[] = []

      // Kategorileri senkronize et
      if (options.syncCategories) {
        const categoryResult = await this.syncCategories()
        totalSynced += categoryResult.syncedItems
        totalFailed += categoryResult.failedItems
        if (categoryResult.errors) {
          errors.push(...categoryResult.errors)
        }
      }

      // √úr√ºnleri senkronize et
      if (options.syncProducts) {
        const productResult = await this.syncProducts()
        totalSynced += productResult.syncedItems
        totalFailed += productResult.failedItems
        if (productResult.errors) {
          errors.push(...productResult.errors)
        }
      }

      // Fiyatlarƒ± senkronize et
      if (options.syncPrices) {
        const priceResult = await this.syncPrices()
        totalSynced += priceResult.syncedItems
        totalFailed += priceResult.failedItems
        if (priceResult.errors) {
          errors.push(...priceResult.errors)
        }
      }

      // Stok durumlarƒ±nƒ± senkronize et
      if (options.syncAvailability) {
        const availabilityResult = await this.syncAvailability()
        totalSynced += availabilityResult.syncedItems
        totalFailed += availabilityResult.failedItems
        if (availabilityResult.errors) {
          errors.push(...availabilityResult.errors)
        }
      }

      const success = totalFailed === 0
      const message = success 
        ? `Getir Food senkronizasyonu tamamlandƒ±: ${totalSynced} √∂ƒüe senkronize edildi`
        : `Getir Food senkronizasyonu tamamlandƒ±: ${totalSynced} ba≈üarƒ±lƒ±, ${totalFailed} hatalƒ±`

      return {
        success,
        message,
        syncedItems: totalSynced,
        failedItems: totalFailed,
        errors: errors.length > 0 ? errors : undefined
      }
    } catch (error) {
      console.error('‚ùå Getir Food sync error:', error)
      return {
        success: false,
        message: 'Getir Food senkronizasyonu ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // √úr√ºnleri senkronize et
  private async syncProducts(): Promise<GetirFoodSyncResult> {
    try {
      // Getir Food'dan mevcut √ºr√ºnleri al
      const menuResult = await this.client.getMenu()
      
      if (!menuResult.success) {
        return {
          success: false,
          message: 'Getir Food men√ºs√º alƒ±namadƒ±',
          syncedItems: 0,
          failedItems: 0,
          errors: [menuResult.error || 'Unknown error']
        }
      }

      // ƒ∞√ß sistemdeki √ºr√ºnleri al
      const { data: internalProducts, error } = await supabase
        .from('products')
        .select(`
          *,
          categories(id, name),
          product_variants(*),
          product_portions(*)
        `)
        .eq('restaurant_id', this.restaurantId)
        .eq('is_available', true)

      if (error) throw error

      let synced = 0
      let failed = 0
      const errors: string[] = []

      // ≈ûimdilik sadece mevcut √ºr√ºnleri mapping'e kaydet
      for (const product of internalProducts || []) {
        try {
          // Getir Food'da benzer isimli √ºr√ºn var mƒ± kontrol et
          const existingProduct = menuResult.data?.products?.find(
            (getirProduct: any) => getirProduct.name.toLowerCase() === product.name.toLowerCase()
          )
          
          if (existingProduct) {
            // Platform mapping'i kaydet
            await this.savePlatformMapping(product.id, existingProduct.id, existingProduct.name)
            synced++
          } else {
            // √úr√ºn bulunamadƒ±, manuel e≈üle≈ütirme gerekebilir
            failed++
            errors.push(`√úr√ºn "${product.name}" Getir Food'da bulunamadƒ±`)
          }
        } catch (error) {
          failed++
          errors.push(`√úr√ºn "${product.name}" hatasƒ±: ${error instanceof Error ? error.message : 'Unknown error'}`)
        }
      }

      return {
        success: failed === 0,
        message: `√úr√ºn senkronizasyonu tamamlandƒ±: ${synced} ba≈üarƒ±lƒ±, ${failed} hatalƒ±`,
        syncedItems: synced,
        failedItems: failed,
        errors: errors.length > 0 ? errors : undefined
      }
    } catch (error) {
      console.error('‚ùå Product sync error:', error)
      return {
        success: false,
        message: '√úr√ºn senkronizasyonu ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // Kategorileri senkronize et
  private async syncCategories(): Promise<GetirFoodSyncResult> {
    try {
      // Getir Food'dan mevcut kategorileri al
      const categoriesResult = await this.client.getCategories()
      
      if (!categoriesResult.success) {
        return {
          success: false,
          message: 'Getir Food kategorileri alƒ±namadƒ±',
          syncedItems: 0,
          failedItems: 0,
          errors: [categoriesResult.error || 'Unknown error']
        }
      }

      // ƒ∞√ß sistemdeki kategorileri al
      const { data: internalCategories, error } = await supabase
        .from('categories')
        .select('*')
        .eq('restaurant_id', this.restaurantId)
        .eq('is_active', true)

      if (error) throw error

      let synced = 0
      let failed = 0
      const errors: string[] = []

      // Kategorileri e≈üle≈ütir
      for (const category of internalCategories || []) {
        try {
          // Getir Food'da benzer isimli kategori var mƒ± kontrol et
          const existingCategory = categoriesResult.data?.find(
            (getirCategory: any) => getirCategory.name.toLowerCase() === category.name.toLowerCase()
          )
          
          if (existingCategory) {
            // Platform mapping'i kaydet (kategoriler i√ßin ayrƒ± tablo gerekebilir)
            synced++
          } else {
            // Kategori bulunamadƒ±
            failed++
            errors.push(`Kategori "${category.name}" Getir Food'da bulunamadƒ±`)
          }
        } catch (error) {
          failed++
          errors.push(`Kategori "${category.name}" hatasƒ±: ${error instanceof Error ? error.message : 'Unknown error'}`)
        }
      }

      return {
        success: failed === 0,
        message: `Kategori senkronizasyonu tamamlandƒ±: ${synced} ba≈üarƒ±lƒ±, ${failed} hatalƒ±`,
        syncedItems: synced,
        failedItems: failed,
        errors: errors.length > 0 ? errors : undefined
      }
    } catch (error) {
      console.error('‚ùå Category sync error:', error)
      return {
        success: false,
        message: 'Kategori senkronizasyonu ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // Fiyatlarƒ± senkronize et
  private async syncPrices(): Promise<GetirFoodSyncResult> {
    try {
      // Platform mapping'lerini al
      const { data: mappings, error } = await supabase
        .from('platform_product_mappings')
        .select(`
          *,
          products(id, name, base_price)
        `)
        .eq('restaurant_id', this.restaurantId)
        .eq('platform', 'getir')
        .eq('price_sync_enabled', true)

      if (error) throw error

      let synced = 0
      let failed = 0
      const errors: string[] = []

      // Her mapping i√ßin fiyat g√ºncelle
      for (const mapping of mappings || []) {
        try {
          const product = (mapping as any).products
          if (!product) continue

          // Getir Food'da √ºr√ºn fiyatƒ±nƒ± g√ºncelle
          const updateResult = await this.client.updateProduct(mapping.external_product_id, {
            price: product.base_price
          })

          if (updateResult.success) {
            synced++
            // Son senkronizasyon zamanƒ±nƒ± g√ºncelle
            await this.updateMappingSync(mapping.id, 'synced')
          } else {
            failed++
            errors.push(`√úr√ºn "${product.name}" fiyat g√ºncelleme hatasƒ±: ${updateResult.error}`)
            await this.updateMappingSync(mapping.id, 'error')
          }
        } catch (error) {
          failed++
          errors.push(`Mapping ${mapping.id} hatasƒ±: ${error instanceof Error ? error.message : 'Unknown error'}`)
          await this.updateMappingSync(mapping.id, 'error')
        }
      }

      return {
        success: failed === 0,
        message: `Fiyat senkronizasyonu tamamlandƒ±: ${synced} ba≈üarƒ±lƒ±, ${failed} hatalƒ±`,
        syncedItems: synced,
        failedItems: failed,
        errors: errors.length > 0 ? errors : undefined
      }
    } catch (error) {
      console.error('‚ùå Price sync error:', error)
      return {
        success: false,
        message: 'Fiyat senkronizasyonu ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // Stok durumlarƒ±nƒ± senkronize et
  private async syncAvailability(): Promise<GetirFoodSyncResult> {
    try {
      // Platform mapping'lerini al
      const { data: mappings, error } = await supabase
        .from('platform_product_mappings')
        .select(`
          *,
          products(id, name, is_available)
        `)
        .eq('restaurant_id', this.restaurantId)
        .eq('platform', 'getir')
        .eq('availability_sync_enabled', true)

      if (error) throw error

      let synced = 0
      let failed = 0
      const errors: string[] = []

      // Her mapping i√ßin stok durumu g√ºncelle
      for (const mapping of mappings || []) {
        try {
          const product = (mapping as any).products
          if (!product) continue

          // Getir Food'da √ºr√ºn stok durumunu g√ºncelle
          const updateResult = await this.client.updateProductAvailability(
            mapping.external_product_id, 
            product.is_available
          )

          if (updateResult.success) {
            synced++
            // Son senkronizasyon zamanƒ±nƒ± g√ºncelle
            await this.updateMappingSync(mapping.id, 'synced')
          } else {
            failed++
            errors.push(`√úr√ºn "${product.name}" stok durumu g√ºncelleme hatasƒ±: ${updateResult.error}`)
            await this.updateMappingSync(mapping.id, 'error')
          }
        } catch (error) {
          failed++
          errors.push(`Mapping ${mapping.id} hatasƒ±: ${error instanceof Error ? error.message : 'Unknown error'}`)
          await this.updateMappingSync(mapping.id, 'error')
        }
      }

      return {
        success: failed === 0,
        message: `Stok durumu senkronizasyonu tamamlandƒ±: ${synced} ba≈üarƒ±lƒ±, ${failed} hatalƒ±`,
        syncedItems: synced,
        failedItems: failed,
        errors: errors.length > 0 ? errors : undefined
      }
    } catch (error) {
      console.error('‚ùå Availability sync error:', error)
      return {
        success: false,
        message: 'Stok durumu senkronizasyonu ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // Platform mapping'i kaydet
  private async savePlatformMapping(
    internalProductId: string, 
    externalProductId: string, 
    externalProductName: string
  ): Promise<void> {
    try {
      // Mevcut mapping var mƒ± kontrol et
      const { data: existingMapping, error: selectError } = await supabase
        .from('platform_product_mappings')
        .select('id')
        .eq('restaurant_id', this.restaurantId)
        .eq('platform', 'getir')
        .eq('internal_product_id', internalProductId)
        .single()

      if (selectError && selectError.code !== 'PGRST116') {
        throw selectError
      }

      // ƒ∞√ß √ºr√ºn bilgisini al
      const { data: internalProduct, error: productError } = await supabase
        .from('products')
        .select('name')
        .eq('id', internalProductId)
        .single()

      if (productError) throw productError

      const mappingData = {
        restaurant_id: this.restaurantId,
        platform: 'getir',
        internal_product_id: internalProductId,
        external_product_id: externalProductId,
        external_product_name: externalProductName,
        internal_product_name: internalProduct.name,
        price_sync_enabled: true,
        availability_sync_enabled: true,
        last_synced_at: new Date().toISOString(),
        sync_status: 'synced',
        updated_at: new Date().toISOString()
      }

      if (existingMapping) {
        // Mevcut mapping'i g√ºncelle
        const { error: updateError } = await supabase
          .from('platform_product_mappings')
          .update(mappingData)
          .eq('id', existingMapping.id)

        if (updateError) throw updateError
      } else {
        // Yeni mapping olu≈ütur
        const { error: insertError } = await supabase
          .from('platform_product_mappings')
          .insert(mappingData)

        if (insertError) throw insertError
      }
    } catch (error) {
      console.error('‚ùå Platform mapping save error:', error)
      throw error
    }
  }

  // Mapping senkronizasyon durumunu g√ºncelle
  private async updateMappingSync(mappingId: string, status: 'synced' | 'pending' | 'error'): Promise<void> {
    try {
      const { error } = await supabase
        .from('platform_product_mappings')
        .update({
          sync_status: status,
          last_synced_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', mappingId)

      if (error) throw error
    } catch (error) {
      console.error('‚ùå Mapping sync update error:', error)
    }
  }

  // Restoran men√ºs√ºn√º al
  async getRestaurantMenu(): Promise<GetirFoodSyncResult & { data?: any }> {
    try {
      const result = await this.client.getMenu()
      
      if (result.success) {
        return {
          success: true,
          message: 'Getir Food men√ºs√º ba≈üarƒ±yla alƒ±ndƒ±',
          syncedItems: 1,
          failedItems: 0,
          data: result.data
        }
      } else {
        return {
          success: false,
          message: 'Getir Food men√ºs√º alƒ±namadƒ±',
          syncedItems: 0,
          failedItems: 1,
          errors: [result.error || 'Unknown error']
        }
      }
    } catch (error) {
      console.error('‚ùå Get restaurant menu error:', error)
      return {
        success: false,
        message: 'Getir Food men√ºs√º alƒ±namadƒ±',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // √úr√ºn durumunu g√ºncelle
  async updateProductAvailability(productId: string, isAvailable: boolean): Promise<GetirFoodSyncResult> {
    try {
      console.log('üîÑ Sync service updating product availability...', { productId, isAvailable })
      
      const result = await this.client.updateProductAvailability(productId, isAvailable)
      
      if (result.success) {
        return {
          success: true,
          message: `√úr√ºn durumu ${isAvailable ? 'aktif' : 'pasif'} olarak g√ºncellendi`,
          syncedItems: 1,
          failedItems: 0
        }
      } else {
        return {
          success: false,
          message: '√úr√ºn durumu g√ºncellenemedi',
          syncedItems: 0,
          failedItems: 1,
          errors: [result.error || 'Unknown error']
        }
      }
    } catch (error) {
      console.error('‚ùå Sync service product availability update error:', error)
      return {
        success: false,
        message: '√úr√ºn durumu g√ºncelleme ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // Kategori durumunu g√ºncelle
  async updateCategoryAvailability(categoryId: string, isAvailable: boolean): Promise<GetirFoodSyncResult> {
    try {
      console.log('üîÑ Sync service updating category availability...', { categoryId, isAvailable })
      
      const result = await this.client.updateCategoryAvailability(categoryId, isAvailable)
      
      if (result.success) {
        return {
          success: true,
          message: `Kategori durumu ${isAvailable ? 'aktif' : 'pasif'} olarak g√ºncellendi`,
          syncedItems: 1,
          failedItems: 0
        }
      } else {
        return {
          success: false,
          message: 'Kategori durumu g√ºncellenemedi',
          syncedItems: 0,
          failedItems: 1,
          errors: [result.error || 'Unknown error']
        }
      }
    } catch (error) {
      console.error('‚ùå Sync service category availability update error:', error)
      return {
        success: false,
        message: 'Kategori durumu g√ºncelleme ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  // Baƒülantƒ± testi
  async testConnection(): Promise<GetirFoodSyncResult> {
    try {
      const result = await this.client.testConnection()
      
      if (result.success) {
        return {
          success: true,
          message: result.data?.message || 'Getir Food baƒülantƒ±sƒ± ba≈üarƒ±lƒ±',
          syncedItems: 1,
          failedItems: 0
        }
      } else {
        return {
          success: false,
          message: 'Getir Food baƒülantƒ± testi ba≈üarƒ±sƒ±z',
          syncedItems: 0,
          failedItems: 1,
          errors: [result.error || 'Unknown error']
        }
      }
    } catch (error) {
      console.error('‚ùå Connection test error:', error)
      return {
        success: false,
        message: 'Getir Food baƒülantƒ± testi ba≈üarƒ±sƒ±z',
        syncedItems: 0,
        failedItems: 1,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }
}

// Factory fonksiyonu
export const createGetirFoodSyncService = async (restaurantId: string): Promise<GetirFoodSyncService | null> => {
  try {
    // Restoran i√ßin Getir Food entegrasyonu ayarlarƒ±nƒ± al
    const { data: integrationSettings, error } = await supabase
      .from('integration_settings')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .eq('platform', 'getir')
      .eq('is_active', true)
      .single()

    if (error) {
      console.error('‚ùå Getir Food integration settings not found:', error)
      return null
    }

    // Getir Food client olu≈ütur
    const client = new GetirFoodClient({
      appSecretKey: integrationSettings.app_secret_key,
      restaurantSecretKey: integrationSettings.restaurant_secret_key,
      environment: integrationSettings.environment || 'production'
    })

    // Sync service olu≈ütur
    return new GetirFoodSyncService(client, restaurantId)
  } catch (error) {
    console.error('‚ùå Failed to create Getir Food sync service:', error)
    return null
  }
} 